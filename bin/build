#!/usr/bin/env node

'use strict';

let childProcess = require('child_process');
let https        = require('https');
let fs           = require('mz/fs');
let config       = require('../config.json');
let lzma         = require('lzma-native');
let tar          = require('tar');
let path         = require('path');
let fstream      = require('fstream');
let zlib         = require('zlib');

const version = childProcess.execSync(__dirname+'/version', {encoding: 'utf8'}).trim();
// TODO: look up channel
const channel = 'dev';
const revision = childProcess.execSync('git log -n 1 --pretty=format:"%H"');
const os = 'darwin';
const arch = 'amd64';
const dir = `./dist/heroku-${os}-${arch}`;
const binPath = `${dir}/heroku-cli`;
const nodePath = `${dir}/node-${config.nodeVersion}-${os}-${arch}`;
const ldflags = `-X=main.Version=${version} -X=main.Channel=${channel} -X=main.GitSHA=${revision}`;
const npmPath = './dist/npm.tar.gz';

let mkdirp = dir => new Promise((ok, fail) => require('mkdirp')(dir, err => err ? fail(err) : ok()));
let rimraf = dir => new Promise((ok, fail) => require('rimraf')(dir, err => err ? fail(err) : ok()));
let ncp = (s, d) => new Promise((ok, fail) => require('ncp')(s, d, err => err ? fail(err) : ok()));

let httpGet = url => {
  console.log(`HTTP GET ${url}`);
  return new Promise((ok, fail) => {
    https.get(url, res => {
      if (res.statusCode >= 300 && res.statusCode <= 399) return ok(httpGet(res.headers.location));
      if (res.statusCode <= 199 || res.statusCode >= 400) return fail(new Error(`${res.statusCode}:${url}`));
      ok(res);
    });
  });
};

let download = (url, file) => {
  return mkdirp(path.dirname(file))
  .then(() => httpGet(url))
  .then(res => new Promise((ok, fail) => {
    console.log(`saving to ${file}`);
    res.pipe(fs.createWriteStream(file)
             .on('error', fail)
             .on('close', ok));
  }));
};

let downloadXZ = (url, file) => {
  return mkdirp(path.dirname(file))
  .then(() => httpGet(url))
  .then(res => new Promise((ok, fail) => {
    console.log(`xz decompressing to ${file}`);
    res.pipe(lzma.createDecompressor().on('error', fail))
    .pipe(fs.createWriteStream(file)
             .on('error', fail)
             .on('close', ok));
  }));
};

let extractTarGZ = (from, to) => {
  console.log(`extracting ${from} to ${to}`);
  return new Promise((ok, fail) => {
    let extractor = tar.Extract({path: to}).on('error', fail).on('end', ok);
    from = typeof from === 'string' ? fs.createReadStream(from) : from;
    from.pipe(zlib.createGunzip()).pipe(extractor);
  });
};

let tarDirectory = (dir, file) => {
  console.log(`tarring ${dir} to ${file}`);
  return new Promise((ok, fail) => {
    let packer = tar.Pack().on('error', fail).on('end', ok);
    fstream.Reader({path: dir, type: 'Directory'})
    .on('error', fail)
    .pipe(packer)
    .pipe(fs.createWriteStream(file).on('error', fail).on('end', ok));
  });
};

let exec = (cmd, opts) => {
  return new Promise((ok, fail) => {
    opts = Object.assign({}, opts);
    opts.env = Object.assign({}, process.env, opts.env);
    childProcess.exec(cmd, opts, (error, stdout, stderr) => {
      if (error) return fail(error);
      ok([stdout, stderr]);
    });
  });
};

let spawn = (cmd, args, opts) => {
  return new Promise((ok, fail) => {
    console.log(`> ${cmd} ${args.join(' ')}`);
    opts = Object.assign({stdio: 'inherit'}, opts);
    opts.env = Object.assign({}, process.env, opts.env);
    childProcess.spawn(cmd, args, opts)
    .on('error', fail)
    .on('close', code => code === 0 ? ok() : fail(`${cmd} ${args.join(' ')} exit code: ${code}`));
  });
};

let downloadNode = (os, arch, file) => {
  let base = `v${config.nodeVersion}-darwin-x64`;
  let archive = `${base}.tar.gz`;
  return httpGet(`https://nodejs.org/download/release/${archive}`)
  .then(res => extractTarGZ(res, `./tmp`));
};

let installPlugins = () => {
  let plugins = Object.keys(config.plugins).map(p => `${p}@${config.plugins[p]}`);
  return mkdirp('./dist/node_modules')
  .then(() => spawn('npm', ['install'].concat(plugins), {cwd: './dist/'}));
};

process.on('unhandledRejection', err => console.error(err));

spawn('go', ['build', '-o', binPath, '-ldflags', ldflags], {GOOS: os, GOARCH: arch})
.then(() => downloadNode(os, arch, nodePath))
.then(() => fs.chmod(nodePath, 0o755))
.then(() => extractTarGZ(npmPath, dir))
.then(() => download(`https://github.com/npm/npm/archive/v${config.npmVersion}.tar.gz`, npmPath))
.then(() => installPlugins())
.then(() => ncp(`./dist/node_modules`, `${dir}/node_modules`))
.then(() => tarDirectory(dir, `${dir}.tar`))
.then(() => rimraf(dir))
.then(() => rimraf('./dist/node_modules'))
.then(() => console.log('done'))
.catch(err => {console.error(err.stack || err); process.exit(1);});
